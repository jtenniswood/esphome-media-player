# =============================================================================
# ACCENT COLOR - Extract dominant color from album art
# =============================================================================
# Samples a grid of pixels from the downloaded artwork, weighted by colour
# saturation so vivid pixels dominate over blacks/whites/grays, and applies
# the result to the accent_bg_panel widget background.
#
# Reads the raw RGB565 buffer directly (little-endian byte order) because
# Image::get_pixel() always decodes as big-endian, producing wrong colours
# when byte_order is little_endian.
# =============================================================================

script:
  - id: extract_accent_color
    mode: restart
    then:
      - lambda: |-
          auto *img = id(album_art_background);
          int img_w = img->get_width();
          int img_h = img->get_height();
          if (img_w <= 0 || img_h <= 0) return;

          lv_img_dsc_t *dsc = img->get_lv_img_dsc();
          const uint8_t *data = dsc->data;
          if (!data) return;

          int grid = 12;
          int step_x = img_w / grid;
          int step_y = img_h / grid;
          if (step_x < 1) step_x = 1;
          if (step_y < 1) step_y = 1;

          int64_t r_wsum = 0, g_wsum = 0, b_wsum = 0;
          int64_t w_total = 0;

          for (int sy = step_y / 2; sy < img_h; sy += step_y) {
            for (int sx = step_x / 2; sx < img_w; sx += step_x) {
              int pos = (sx + sy * img_w) * 2;
              uint16_t rgb565 = data[pos] | (data[pos + 1] << 8);

              int r = ((rgb565 >> 11) & 0x1F);
              int g = ((rgb565 >> 5) & 0x3F);
              int b = (rgb565 & 0x1F);
              r = (r << 3) | (r >> 2);
              g = (g << 2) | (g >> 4);
              b = (b << 3) | (b >> 2);

              int mx = r > g ? (r > b ? r : b) : (g > b ? g : b);
              int mn = r < g ? (r < b ? r : b) : (g < b ? g : b);
              int sat = mx - mn;

              int weight = sat * sat + 1;
              r_wsum += (int64_t)r * weight;
              g_wsum += (int64_t)g * weight;
              b_wsum += (int64_t)b * weight;
              w_total += weight;
            }
          }

          if (w_total > 0) {
            int r = (int)(r_wsum / w_total);
            int g = (int)(g_wsum / w_total);
            int b = (int)(b_wsum / w_total);
            ESP_LOGI("accent", "Accent color: rgb(%d,%d,%d)", r, g, b);

            int dr = r / 3, dg = g / 3, db = b / 3;
            lv_obj_set_style_bg_color(id(accent_bg_panel), lv_color_make(dr, dg, db), 0);
            lv_obj_set_style_bg_color(id(media_play_pause_button), lv_color_make(r, g, b), 0);
          }
