# =============================================================================
# HARDWARE CONFIGURATION - Guition ESP32-S3-4848S040
# =============================================================================
# This file defines the physical hardware settings for the ESP32 touchscreen.
# It tells ESPHome how to communicate with the display, touchscreen, and
# other components on this specific device.
#
# WARNING: These settings are specific to the Guition ESP32-S3-4848S040.
#          Using this config with a different device may cause issues.
# =============================================================================


# -----------------------------------------------------------------------------
# PROCESSOR / BOARD
# -----------------------------------------------------------------------------
# Defines which ESP32 chip and development framework to use.
# - board: The ESP32-S3 development kit configuration
# - framework: esp-idf is Espressif's official development framework
#              (more powerful than Arduino, required for this display)
# -----------------------------------------------------------------------------
esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  framework:
    type: esp-idf


# -----------------------------------------------------------------------------
# ESPHOME DEVICE IDENTITY
# -----------------------------------------------------------------------------
# Basic device information visible in Home Assistant.
# - name: Internal hostname (used for mDNS, e.g., device-name.local)
# - friendly_name: Human-readable name shown in Home Assistant UI
# - area: Which room/area this device belongs to in Home Assistant
#
# These values come from variables ($name, etc.) defined in template.yaml
# -----------------------------------------------------------------------------
esphome:
  name: ${name}
  friendly_name: ${friendly_name}


# -----------------------------------------------------------------------------
# OVER THE AIR (OTA) UPDATES
# -----------------------------------------------------------------------------
# Allows updating the firmware wirelessly without plugging in USB.
# Once configured, you can flash new code from ESPHome dashboard.
# -----------------------------------------------------------------------------
ota:
  - platform: esphome


# -----------------------------------------------------------------------------
# HOME ASSISTANT API
# -----------------------------------------------------------------------------
# Enables communication between this device and Home Assistant.
# Without this, the device won't appear in Home Assistant.
# The encryption key is typically set in your secrets.yaml file.
# -----------------------------------------------------------------------------
api:
  on_client_connected:
    - lambda: |-
        id(ha_base_url) = "http://" + client_address + ":8123";
    - lvgl.widget.hide: ha_setup_prompt
    - script.execute: subscribe_media_player
    - script.execute: subscribe_tv_media_player
  on_client_disconnected:
    - lvgl.widget.hide: setup_prompt
    - lvgl.widget.show: ha_setup_prompt


# -----------------------------------------------------------------------------
# LOGGING
# -----------------------------------------------------------------------------
# Outputs debug messages for troubleshooting.
# View logs in ESPHome dashboard or via serial connection.
# -----------------------------------------------------------------------------
logger:


# -----------------------------------------------------------------------------
# PSRAM (External Memory)
# -----------------------------------------------------------------------------
# The display requires extra memory for graphics. PSRAM is external RAM
# soldered onto the board that supplements the ESP32's internal memory.
# - mode: octal = 8-bit data bus (faster than quad mode)
# - speed: 80MHz clock speed for memory access
#
# Without this, the display won't have enough memory for the framebuffer.
# -----------------------------------------------------------------------------
psram:
  mode: octal
  speed: 80MHz


# -----------------------------------------------------------------------------
# BACKLIGHT CONTROL
# -----------------------------------------------------------------------------
# The display backlight is controlled via PWM (pulse width modulation).
# This allows dimming the screen brightness from 0-100%.
# - pin: GPIO38 controls the backlight
# - frequency: 150Hz PWM frequency (fast enough to avoid flicker)
# - min_power: Minimum brightness level (1% - prevents fully dark)
# - zero_means_zero: When set to 0, backlight turns completely off
#
# This output is used by the backlight component in addon/backlight.yaml
# -----------------------------------------------------------------------------
output:
  - platform: ledc
    id: backlight_output
    pin: GPIO38
    frequency: 150Hz
    min_power: 0.01
    zero_means_zero: true


# -----------------------------------------------------------------------------
# SPI BUS (Display Communication)
# -----------------------------------------------------------------------------
# SPI (Serial Peripheral Interface) is how the ESP32 sends data to the display.
# - clk_pin: Clock signal (GPIO48) - synchronizes data transfer
# - mosi_pin: Master Out Slave In (GPIO47) - data sent TO the display
#
# This SPI bus is used by the display configuration below.
# -----------------------------------------------------------------------------
spi:
  - id: lcd_spi
    clk_pin: GPIO48
    mosi_pin: GPIO47


# -----------------------------------------------------------------------------
# I2C BUS (Touchscreen Communication)
# -----------------------------------------------------------------------------
# I2C is how the ESP32 communicates with the touchscreen controller.
# - sda: Data line (GPIO19)
# - scl: Clock line (GPIO45)
# - ignore_strapping_warning: GPIO45 is a "strapping pin" used during boot.
#   This warning is expected and can be safely ignored for this device.
#
# This I2C bus is used by the touchscreen configuration below.
# -----------------------------------------------------------------------------
i2c:
  id: touchscreen_bus
  sda: GPIO19
  scl:
    number: 45
    ignore_strapping_warning: true


# -----------------------------------------------------------------------------
# GLOBAL STATE VARIABLES
# -----------------------------------------------------------------------------
# Shared state used across touch handling, gesture detection, UI visibility,
# and the settings panel. These persist for the lifetime of the device and are
# accessed from touchscreen handlers, scripts, and lambdas.
# -----------------------------------------------------------------------------
globals:
  # -- Touch tracking (swipe gesture detection) --
  - id: touch_x_start            # X coordinate when finger first touches
    type: int
    initial_value: '0'
  - id: touch_y_start            # Y coordinate when finger first touches
    type: int
    initial_value: '0'
  - id: touch_x_end              # X coordinate updated as finger moves
    type: int
    initial_value: '0'
  - id: touch_y_end              # Y coordinate updated as finger moves
    type: int
    initial_value: '0'

  # -- UI overlay visibility --
  - id: is_ui_hidden             # True when title/artist/play button are hidden
    type: bool
    initial_value: 'false'
  - id: is_screen_dimmed         # True when backlight is in dimmed/idle state
    type: bool
    initial_value: 'false'
  - id: was_screen_dimmed        # Snapshot at touch-start; prevents toggle on wake
    type: bool
    initial_value: 'false'

  # -- Settings panel state --
  - id: is_panel_open            # True when the swipe-down settings panel is visible
    type: bool
    initial_value: 'false'
  - id: was_panel_open           # Snapshot at touch-start; blocks bleed-through taps
    type: bool
    initial_value: 'false'

  # -- Setup flow --
  - id: actions_prompt_acked
    type: bool
    restore_value: true
    initial_value: 'false'

  # -- TV source mode --
  - id: is_tv_mode
    type: bool
    initial_value: 'false'
  - id: last_tv_media_position
    type: float
    initial_value: '0.0'
  - id: last_tv_position_timestamp
    type: int
    initial_value: '0'
  - id: tv_ha_position_epoch
    type: int
    initial_value: '0'
  - id: tv_title_received_once
    type: bool
    initial_value: 'false'


# -----------------------------------------------------------------------------
# TOUCHSCREEN (GT911 Controller)
# -----------------------------------------------------------------------------
# The GT911 is the touch controller chip on this display.
# It detects finger touches and reports X/Y coordinates.
# - display: Links to the display so touch coordinates match screen position
#
# Touch events are automatically forwarded to LVGL for button presses.
# Swipe detection: on_touch stores start position, on_update tracks the
# finger as it moves, on_release evaluates whether the gesture was a swipe.
# -----------------------------------------------------------------------------
touchscreen:
  - platform: gt911
    id: tft_touch
    display: tft_display
    on_touch:
      - lambda: |-
          id(was_screen_dimmed) = id(is_screen_dimmed);
          id(was_panel_open) = id(is_panel_open);
          id(touch_x_start) = touch.x;
          id(touch_y_start) = touch.y;
          id(touch_x_end) = touch.x;
          id(touch_y_end) = touch.y;
      - script.execute: backlight_wake_timeout
    on_update:
      - lambda: |-
          for (auto touch: touches) {
            if (touch.state <= 2) {
              id(touch_x_end) = touch.x;
              id(touch_y_end) = touch.y;
            }
          }
    on_release:
      - lambda: |-
          int dx = id(touch_x_end) - id(touch_x_start);
          int dy = id(touch_y_end) - id(touch_y_start);
          int sy = id(touch_y_start);

          // --- Dismiss actions prompt on tap ---
          if (!lv_obj_has_flag(id(actions_prompt), LV_OBJ_FLAG_HIDDEN)) {
            if (abs(dx) < 20 && abs(dy) < 20) {
              lv_obj_add_flag(id(actions_prompt), LV_OBJ_FLAG_HIDDEN);
              id(actions_prompt_acked) = true;
            }
            return;
          }

          // --- Vertical swipe: settings panel open/close ---
          // Swipe down to open: 30px+ downward movement, panel closed
          if (dy > 20 && abs(dy) > abs(dx) * 2 && !id(is_panel_open)) {
            id(open_settings_panel).execute();
            return;
          }
          // Swipe up to close: panel is open
          if (dy < -60 && abs(dy) > abs(dx) * 2 && id(is_panel_open)) {
            id(close_settings_panel).execute();
            return;
          }
          // When panel is (or was) open, ignore all main-screen gestures.
          // was_panel_open guards against the close button tap bleeding
          // through to toggle_ui after the panel has already been hidden.
          if (id(is_panel_open) || id(was_panel_open)) {
            return;
          }

          // --- Horizontal swipe: track navigation ---
          if (abs(dx) > 80 && abs(dx) > abs(dy) * 2) {
            if (dx > 0) {
              id(swipe_previous_track).execute();
            } else {
              id(swipe_next_track).execute();
            }
          }
          // Tap: minimal movement anywhere on screen — toggle UI visibility
          // Excludes the play/pause button area (x:390-462, y:356-428).
          // If screen was dimmed, just wake it (don't hide the UI).
          // Only allow hiding the UI when media is actively playing.
          else if (abs(dx) < 20 && abs(dy) < 20) {
            int sx = id(touch_x_start);
            // Ignore taps on the play/pause button
            if (sx >= 385 && sx <= 467 && sy >= 351 && sy <= 433) {
              return;
            }
            if (id(was_screen_dimmed)) {
              // Screen was dimmed — wake only, don't toggle
            } else if (id(is_ui_hidden)) {
              // UI is hidden — always allow showing it
              id(toggle_ui).execute();
            } else {
              bool playing = id(is_tv_mode)
                  ? (id(tv_media_player_state_sensor).has_state() && id(tv_media_player_state_sensor).state == "playing")
                  : (id(media_player_state_sensor).has_state() && id(media_player_state_sensor).state == "playing");
              if (playing) id(toggle_ui).execute();
            }
          }


# -----------------------------------------------------------------------------
# INTERACTION SCRIPTS
# -----------------------------------------------------------------------------
# Scripts triggered by touch gestures and UI events:
#   toggle_ui           – Tap to show/hide the now-playing overlay (fade anim)
#   swipe_next_track    – Swipe left to skip to the next track
#   swipe_previous_track– Swipe right to go back to the previous track
#   open_settings_panel – Swipe down to reveal the settings panel
#   close_settings_panel– Swipe up (or tap close) to hide the settings panel
#   show_track_view     – Resets to the main now-playing view (closes panel,
#                         shows overlay); called when new media starts
#
# mode: single  – ignores re-triggers while already running
# mode: restart – cancels the in-progress run and starts fresh
# -----------------------------------------------------------------------------
script:
  # -- Toggle now-playing overlay (fade in / fade out) --
  - id: toggle_ui
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return id(is_ui_hidden);'
          then:
            - lambda: 'id(is_ui_hidden) = false;'
            - lvgl.widget.show: bottom_overlay
            - lvgl.widget.show: media_title_label
            - lvgl.widget.show: media_play_pause_button
            - lvgl.widget.show: media_time_label
            - lambda: |-
                lv_obj_fade_in(id(bottom_overlay), 200, 0);
                lv_obj_fade_in(id(media_title_label), 200, 0);
                if (id(artist_has_content)) {
                  lv_obj_clear_flag(id(media_artist_label), LV_OBJ_FLAG_HIDDEN);
                  lv_obj_fade_in(id(media_artist_label), 200, 0);
                }
                lv_obj_fade_in(id(media_play_pause_button), 200, 0);
                lv_obj_fade_in(id(media_time_label), 200, 0);
          else:
            - lambda: 'id(is_ui_hidden) = true;'
            - lambda: |-
                lv_obj_fade_out(id(bottom_overlay), 300, 0);
                lv_obj_fade_out(id(media_title_label), 300, 0);
                if (id(artist_has_content)) {
                  lv_obj_fade_out(id(media_artist_label), 300, 0);
                }
                lv_obj_fade_out(id(media_play_pause_button), 300, 0);
                lv_obj_fade_out(id(media_time_label), 300, 0);
            - delay: 400ms
            - lvgl.widget.hide: bottom_overlay
            - lvgl.widget.hide: media_title_label
            - lvgl.widget.hide: media_artist_label
            - lvgl.widget.hide: media_play_pause_button
            - lvgl.widget.hide: media_time_label
  # -- Track navigation (called by horizontal swipe gestures) --
  - id: swipe_next_track
    mode: single
    then:
      - homeassistant.service:
          service: media_player.media_next_track
          variables:
            target: !lambda |-
              if (id(is_tv_mode)) return id(tv_media_player_entity).state;
              return id(media_player_entity).state;
          data_template:
            entity_id: "{{ target }}"
  - id: swipe_previous_track
    mode: single
    then:
      - homeassistant.service:
          service: media_player.media_previous_track
          variables:
            target: !lambda |-
              if (id(is_tv_mode)) return id(tv_media_player_entity).state;
              return id(media_player_entity).state;
          data_template:
            entity_id: "{{ target }}"

  # -- Settings panel (called by vertical swipe gestures) --
  - id: open_settings_panel
    mode: single
    then:
      - lambda: 'id(is_panel_open) = true;'
      - lvgl.widget.show: settings_panel
  - id: close_settings_panel
    mode: single
    then:
      - lvgl.widget.hide: settings_panel
      - lambda: 'id(is_panel_open) = false;'

  # -- Debounced volume set (prevents flooding HA during arc drag) --
  - id: debounce_volume
    mode: restart
    then:
      - delay: 250ms
      - homeassistant.service:
          service: media_player.volume_set
          variables:
            target: !lambda |-
              if (id(is_tv_mode)) return id(tv_media_player_entity).state;
              return id(media_player_entity).state;
            vol_level: !lambda 'return lv_arc_get_value(id(volume_arc)) / 100.0f;'
          data_template:
            entity_id: "{{ target }}"
            volume_level: "{{ vol_level }}"

  # -- Reset to now-playing view (e.g. when a new track starts) --
  - id: show_track_view
    mode: single
    then:
      - if:
          condition:
            lambda: 'return id(is_panel_open);'
          then:
            - lvgl.widget.hide: settings_panel
            - lambda: 'id(is_panel_open) = false;'
      - if:
          condition:
            lambda: 'return id(is_ui_hidden);'
          then:
            - script.stop: toggle_ui
            - lambda: 'id(is_ui_hidden) = false;'
            - lvgl.widget.show: bottom_overlay
            - lvgl.widget.show: media_title_label
            - lvgl.widget.show: media_play_pause_button
            - lvgl.widget.show: media_time_label
            - lambda: |-
                lv_obj_fade_in(id(bottom_overlay), 200, 0);
                lv_obj_fade_in(id(media_title_label), 200, 0);
                if (id(artist_has_content)) {
                  lv_obj_clear_flag(id(media_artist_label), LV_OBJ_FLAG_HIDDEN);
                  lv_obj_fade_in(id(media_artist_label), 200, 0);
                }
                lv_obj_fade_in(id(media_play_pause_button), 200, 0);
                lv_obj_fade_in(id(media_time_label), 200, 0);

  # -- TV source mode transitions --
  - id: enter_tv_mode
    mode: single
    then:
      - lambda: 'id(is_tv_mode) = true;'
      - lambda: |-
          // Push current TV sensor values to widgets immediately
          if (id(tv_media_title_sensor).has_state()) {
            std::string title = id(tv_media_title_sensor).state;
            if (title.substr(0, 8) == "(null): ") title = title.substr(8);
            lv_label_set_text(id(media_title_label), title.empty() ? "—" : title.c_str());
          } else {
            lv_label_set_text(id(media_title_label), "TV");
          }
          if (id(tv_media_artist_sensor).has_state() && !id(tv_media_artist_sensor).state.empty()
              && id(tv_media_artist_sensor).state != "—" && id(tv_media_artist_sensor).state != "\xe2\x80\x94") {
            id(artist_has_content) = true;
            lv_label_set_text(id(media_artist_label), id(tv_media_artist_sensor).state.c_str());
            lv_obj_clear_flag(id(media_artist_label), LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_y(id(media_time_label), 438);
          } else {
            id(artist_has_content) = false;
            lv_obj_add_flag(id(media_artist_label), LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_y(id(media_time_label), 406);
          }
      - if:
          condition:
            lambda: 'return id(tv_entity_picture_sensor).has_state() && !id(tv_entity_picture_sensor).state.empty();'
          then:
            - lvgl.widget.update:
                id: album_art_background_widget
                opa: 50%
            - lvgl.widget.hide: artwork_error_label
            - online_image.set_url:
                id: tv_art_background
                url: !lambda |-
                  std::string path = id(tv_entity_picture_sensor).state;
                  while (!path.empty() && (path.back() == '\n' || path.back() == '\r' || path.back() == ' ')) path.pop_back();
                  if (path.substr(0, 7) == "http://" || path.substr(0, 8) == "https://") return path;
                  return id(ha_base_url) + path;
            - script.execute: extract_accent_color
          else:
            - lvgl.widget.update:
                id: album_art_background_widget
                opa: 40%
      - if:
          condition:
            lambda: |-
              return id(tv_media_player_state_sensor).has_state() &&
                     id(tv_media_player_state_sensor).state == "playing";
          then:
            - lvgl.widget.hide: media_play_icon
            - lvgl.widget.show: media_pause_icon
          else:
            - lvgl.widget.show: media_play_icon
            - lvgl.widget.hide: media_pause_icon
      - script.execute: show_track_view

  - id: exit_tv_mode
    mode: single
    then:
      - lambda: |-
          id(is_tv_mode) = false;
          lv_obj_set_style_bg_color(lv_scr_act(), lv_color_make(0, 0, 0), 0);
      - lambda: |-
          // Push current Sonos sensor values back to widgets
          if (id(media_title_sensor).has_state()) {
            auto &t = id(media_title_sensor).state;
            lv_label_set_text(id(media_title_label), t.empty() ? "—" : t.c_str());
          } else {
            lv_label_set_text(id(media_title_label), "—");
          }
          if (id(media_artist_sensor).has_state() && !id(media_artist_sensor).state.empty()
              && id(media_artist_sensor).state != "—" && id(media_artist_sensor).state != "\xe2\x80\x94") {
            id(artist_has_content) = true;
            lv_label_set_text(id(media_artist_label), id(media_artist_sensor).state.c_str());
            lv_obj_clear_flag(id(media_artist_label), LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_y(id(media_time_label), 438);
          } else {
            id(artist_has_content) = false;
            lv_obj_add_flag(id(media_artist_label), LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_y(id(media_time_label), 406);
          }
      - if:
          condition:
            lambda: 'return id(media_entity_picture_sensor).has_state() && !id(media_entity_picture_sensor).state.empty();'
          then:
            - lvgl.widget.update:
                id: album_art_background_widget
                opa: 50%
            - lvgl.widget.hide: artwork_error_label
            - online_image.set_url:
                id: album_art_background
                url: !lambda |-
                  std::string path = id(media_entity_picture_sensor).state;
                  while (!path.empty() && (path.back() == '\n' || path.back() == '\r' || path.back() == ' ')) path.pop_back();
                  if (path.substr(0, 7) == "http://" || path.substr(0, 8) == "https://") return path;
                  return id(ha_base_url) + path;
      - if:
          condition:
            lambda: |-
              return id(media_player_state_sensor).has_state() &&
                     id(media_player_state_sensor).state == "playing";
          then:
            - lvgl.widget.hide: media_play_icon
            - lvgl.widget.show: media_pause_icon
          else:
            - lvgl.widget.show: media_play_icon
            - lvgl.widget.hide: media_pause_icon
      - script.execute: show_track_view


# -----------------------------------------------------------------------------
# DISPLAY (ST7701S LCD Controller)
# -----------------------------------------------------------------------------
# This is the main display configuration. The ST7701S is the LCD driver chip.
#
# DIMENSIONS:
# - 480x480 pixels (square display)
#
# SPI SETTINGS:
# - spi_mode: MODE3 - clock polarity/phase for this display
# - data_rate: 2MHz - speed for sending commands (not pixel data)
#
# COLOR:
# - color_order: RGB - red, green, blue pixel order
# - invert_colors: False - don't invert (black stays black, white stays white)
#
# CONTROL PINS:
# - cs_pin: Chip Select (GPIO39) - enables the display
# - de_pin: Data Enable (GPIO18) - signals valid pixel data
# - hsync_pin: Horizontal Sync (GPIO16) - start of each row
# - vsync_pin: Vertical Sync (GPIO17) - start of each frame
# - pclk_pin: Pixel Clock (GPIO21) - timing for each pixel
#
# TIMING:
# - pclk_frequency: 12MHz pixel clock (how fast pixels are drawn)
# - hsync/vsync pulse_width, front/back_porch: Timing margins required
#   by the display. These values are specific to this hardware.
#
# PERFORMANCE:
# - update_interval: never - LVGL manages screen updates, not ESPHome
# - auto_clear_enabled: False - don't auto-clear (LVGL handles this)
#
# INIT SEQUENCE:
# - Special commands sent to the display on startup
# - These configure internal display settings
#
# DATA PINS:
# - RGB data pins for sending color information (active matrix display)
# - red: 5 pins (5 bits), green: 6 pins (6 bits), blue: 5 pins (5 bits)
# - This is RGB565 format (16-bit color = 65,536 colors)
# -----------------------------------------------------------------------------
display:
  - platform: st7701s
    id: tft_display
    dimensions:
      width: 480
      height: 480
    spi_mode: MODE3
    data_rate: 2MHz
    color_order: RGB
    invert_colors: False
    cs_pin: 39
    de_pin: 18
    hsync_pin: 16
    vsync_pin: 17
    pclk_pin: 21
    pclk_frequency: 12MHz
    pclk_inverted: False
    hsync_pulse_width: 8
    hsync_front_porch: 10
    hsync_back_porch: 20
    vsync_pulse_width: 8
    vsync_front_porch: 10
    vsync_back_porch: 10
    update_interval: never
    auto_clear_enabled: False
    init_sequence:
      - 1
      - [0xFF, 0x77, 0x01, 0x00, 0x00, 0x10] # CMD2_BKSEL_BK0
      - [0xCD, 0x00] # disable MDT flag
    data_pins:
      red: [11, 12, 13, 14, 0]
      green: [8, 20, 3, 46, 9, 10]
      blue: [4, 5, 6, 7, 15]
