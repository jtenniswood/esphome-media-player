# =============================================================================
# TV SENSORS - Secondary media player for TV source mode
# =============================================================================
# Subscribes to ${tv_media_player} attributes and updates LVGL widgets when
# is_tv_mode is true. Mirrors the structure of sensors.yaml but reads from the
# TV entity (e.g. Apple TV) instead of the primary media player (Sonos).
# =============================================================================

text_sensor:
  - platform: homeassistant
    entity_id: ${tv_media_player}
    id: tv_media_title_sensor
    attribute: media_title
    on_value:
      - if:
          condition:
            lambda: 'return id(is_tv_mode);'
          then:
            - script.execute: auto_hide_track_info
            - lvgl.widget.update:
                id: album_art_background_widget
                opa: 50%
            - lvgl.widget.hide: artwork_error_label
            - lvgl.label.update:
                id: media_title_label
                text: !lambda |-
                  std::string title = x;
                  if (title.substr(0, 8) == "(null): ") title = title.substr(8);
                  return title.empty() ? std::string("—") : title;
            - if:
                condition:
                  lambda: 'return id(tv_title_received_once);'
                then:
                  - lambda: |-
                      id(last_tv_media_position) = 0.0f;
                      id(tv_ha_position_epoch) = 0;
                      auto t = id(ha_time).now();
                      if (t.is_valid()) {
                        id(last_tv_position_timestamp) = t.timestamp;
                      }
                  - lvgl.label.update:
                      id: media_time_label
                      text: "0:00 / -0:00"
                  - lvgl.bar.update:
                      id: media_progress_bar
                      value: 0
                else:
                  - lambda: 'id(tv_title_received_once) = true;'

  - platform: homeassistant
    entity_id: ${tv_media_player}
    id: tv_media_artist_sensor
    attribute: media_artist
    on_value:
      - if:
          condition:
            lambda: 'return id(is_tv_mode);'
          then:
            - lvgl.label.update:
                id: media_artist_label
                text: !lambda 'return x.empty() ? std::string("—") : x;'

  - platform: homeassistant
    entity_id: ${tv_media_player}
    id: tv_entity_picture_sensor
    attribute: entity_picture
    on_value:
      - if:
          condition:
            lambda: 'return id(is_tv_mode) && !x.empty();'
          then:
            - lvgl.widget.update:
                id: album_art_background_widget
                opa: 50%
            - lvgl.widget.hide: artwork_error_label
            - online_image.set_url:
                id: album_art_background
                url: !lambda |-
                  std::string path = x;
                  while (!path.empty() && (path.back() == '\n' || path.back() == '\r' || path.back() == ' ')) path.pop_back();
                  if (path.substr(0, 7) == "http://" || path.substr(0, 8) == "https://") {
                    return path;
                  }
                  return id(ha_base_url) + path;
            - online_image.set_url:
                id: tv_art_panel
                url: !lambda |-
                  std::string path = x;
                  while (!path.empty() && (path.back() == '\n' || path.back() == '\r' || path.back() == ' ')) path.pop_back();
                  if (path.substr(0, 7) == "http://" || path.substr(0, 8) == "https://") {
                    return path;
                  }
                  return id(ha_base_url) + path;

  - platform: homeassistant
    entity_id: ${tv_media_player}
    id: tv_media_player_state_sensor
    on_value:
      - if:
          condition:
            lambda: 'return id(is_tv_mode);'
          then:
            - if:
                condition:
                  lambda: 'return x == "playing";'
                then:
                  - script.stop: backlight_wake_timeout
                  - lvgl.resume:
                  - lvgl.widget.hide:
                      id: media_play_icon
                  - lvgl.widget.show:
                      id: media_pause_icon
                  - light.turn_on:
                      id: backlight
                      brightness: 100%
                  - if:
                      condition:
                        lambda: 'return id(is_screen_dimmed);'
                      then:
                        - lambda: 'id(is_screen_dimmed) = false;'
                        - script.execute: show_track_view
                  - script.execute: auto_hide_track_info
                else:
                  - script.stop: auto_hide_track_info
                  - script.execute: show_track_view
                  - lvgl.widget.show:
                      id: media_play_icon
                  - lvgl.widget.hide:
                      id: media_pause_icon
                  - script.execute: backlight_wake_timeout

  - platform: homeassistant
    entity_id: ${tv_media_player}
    id: tv_media_position_updated_at_sensor
    attribute: media_position_updated_at
    on_value:
      - if:
          condition:
            lambda: 'return id(is_tv_mode);'
          then:
            - lambda: |-
                int yr, mo, dy, hr, mn, sc;
                if (sscanf(x.c_str(), "%d-%d-%dT%d:%d:%d", &yr, &mo, &dy, &hr, &mn, &sc) != 6 &&
                    sscanf(x.c_str(), "%d-%d-%d %d:%d:%d", &yr, &mo, &dy, &hr, &mn, &sc) != 6) {
                  return;
                }
                int y = yr, m = mo;
                if (m <= 2) { y--; m += 12; }
                long days = 365L*y + y/4 - y/100 + y/400 + (153*(m-3)+2)/5 + dy - 719469;
                int epoch = (int)(days * 86400L + hr * 3600 + mn * 60 + sc);
                id(tv_ha_position_epoch) = epoch;
                if (id(tv_media_position_sensor).has_state()) {
                  id(last_tv_position_timestamp) = epoch;
                }

sensor:
  - platform: homeassistant
    entity_id: ${tv_media_player}
    id: tv_media_duration_sensor
    attribute: media_duration

  - platform: homeassistant
    entity_id: ${tv_media_player}
    id: tv_media_position_sensor
    attribute: media_position
    on_value:
      - if:
          condition:
            lambda: 'return id(is_tv_mode);'
          then:
            - lambda: |-
                id(last_tv_media_position) = x;
                if (id(tv_ha_position_epoch) != 0) {
                  id(last_tv_position_timestamp) = id(tv_ha_position_epoch);
                } else {
                  auto t = id(ha_time).now();
                  if (t.is_valid()) id(last_tv_position_timestamp) = t.timestamp;
                }
