# =============================================================================
# SENSORS - Music dashboard (media_player.office)
# =============================================================================
# Subscribes to media_player attributes and updates LVGL labels, bar, image,
# and play/pause icon. To use a different entity, override in your main YAML
# with a package override or use a local copy and set entity_id.
# Album art base URL: http://192.168.1.30:8123 (path from HA already includes token).
# =============================================================================

# Store last HA position and time so we can estimate elapsed time between updates
# (HA/Sonos often only push media_position every 5–10s; we tick every 1s)
globals:
  - id: last_media_position
    type: float
    initial_value: '0.0'
  - id: last_position_timestamp
    type: int
    initial_value: '0'
  - id: is_tv_mode
    type: bool
    initial_value: 'false'
  - id: title_received_once
    type: bool
    initial_value: 'false'
  - id: ha_position_epoch
    type: int
    initial_value: '0'

# Refresh progress bar and elapsed time every second; when playing, estimate
# position from last HA update + elapsed time so the clock moves smoothly
interval:
  - interval: 1s
    then:
      - if:
          condition:
            lambda: 'return !id(is_tv_mode);'
          then:
            - lvgl.label.update:
                id: media_time_label
                text: !lambda |-
                  float pos;
                  float dur = id(media_duration_sensor).has_state() ? id(media_duration_sensor).state : 0.0f;
                  bool playing = id(media_player_state_sensor).has_state() &&
                                 id(media_player_state_sensor).state == "playing";
                  auto t = id(sntp_time).now();
                  if (playing && t.is_valid() && id(ha_position_epoch) != 0
                      && id(media_position_sensor).has_state()) {
                    // Primary: HA position + (now − HA timestamp) — mirrors HA frontend calc
                    pos = id(media_position_sensor).state
                        + (float)(t.timestamp - id(ha_position_epoch));
                  } else if (playing && t.is_valid() && id(last_position_timestamp) != 0) {
                    // Fallback: globals (used briefly after track-change reset)
                    pos = id(last_media_position)
                        + (float)(t.timestamp - id(last_position_timestamp));
                  } else {
                    pos = id(media_position_sensor).has_state()
                        ? id(media_position_sensor).state : id(last_media_position);
                  }
                  if (pos < 0) pos = 0;
                  if (dur > 0 && pos > dur) pos = dur;
                  // #region agent log
                  static int _dbg = 0; _dbg++;
                  if (_dbg <= 10 || _dbg % 10 == 0) {
                    ESP_LOGI("dbg", "TICK #%d: pos=%.1f sensor=%.1f ha_ep=%d glob_pos=%.1f glob_ts=%d playing=%d sntp=%d dur=%.1f",
                      _dbg, pos,
                      id(media_position_sensor).has_state() ? id(media_position_sensor).state : -1.0f,
                      id(ha_position_epoch), id(last_media_position), id(last_position_timestamp),
                      playing ? 1 : 0, t.is_valid() ? 1 : 0, dur);
                  }
                  // #endregion
                  int e = (int)pos; if (e < 0) e = 0;
                  int rem = (int)(dur - pos); if (rem < 0) rem = 0;
                  char buf[24];
                  snprintf(buf, sizeof(buf), "%d:%02d / -%d:%02d", e / 60, e % 60, rem / 60, rem % 60);
                  return std::string(buf);
            - lvgl.bar.update:
                id: media_progress_bar
                value: !lambda |-
                  float pos;
                  float dur = id(media_duration_sensor).has_state() ? id(media_duration_sensor).state : 0.0f;
                  bool playing = id(media_player_state_sensor).has_state() &&
                                 id(media_player_state_sensor).state == "playing";
                  auto t = id(sntp_time).now();
                  if (playing && t.is_valid() && id(ha_position_epoch) != 0
                      && id(media_position_sensor).has_state()) {
                    pos = id(media_position_sensor).state
                        + (float)(t.timestamp - id(ha_position_epoch));
                  } else if (playing && t.is_valid() && id(last_position_timestamp) != 0) {
                    pos = id(last_media_position)
                        + (float)(t.timestamp - id(last_position_timestamp));
                  } else {
                    pos = id(media_position_sensor).has_state()
                        ? id(media_position_sensor).state : id(last_media_position);
                  }
                  if (pos < 0) pos = 0;
                  if (dur > 0 && pos > dur) pos = dur;
                  if (dur > 0) return (int)((pos / dur) * 100.0f);
                  return 0;

# ---------------------------------------------------------------------------
# MODE-SWITCH SCRIPTS
# ---------------------------------------------------------------------------
# Reusable scripts to switch between TV mode and music mode.
# Called from media_source_sensor (primary) and as fallback from
# media_entity_picture_sensor so the display switches to music mode
# when album art appears, even if the source attribute stays "TV".
# ---------------------------------------------------------------------------
script:
  - id: enter_tv_mode
    then:
      - lambda: 'id(is_tv_mode) = true;'
      - lvgl.widget.hide: album_art_background_widget
      - lvgl.widget.hide: media_title_label
      - lvgl.widget.hide: media_artist_label
      - lvgl.widget.hide: media_play_pause_button
      - lvgl.widget.hide: media_time_label
      - lvgl.widget.hide: media_progress_bar
      - lvgl.widget.show: tv_source_label
  - id: enter_music_mode
    then:
      - lambda: 'id(is_tv_mode) = false;'
      - lvgl.widget.show: album_art_background_widget
      - lvgl.widget.show: media_title_label
      - lvgl.widget.show: media_artist_label
      - lvgl.widget.show: media_play_pause_button
      - lvgl.widget.show: media_time_label
      - lvgl.widget.show: media_progress_bar
      - lvgl.widget.hide: tv_source_label
  # Auto-show track info on track change, then auto-hide after configured duration.
  # mode: restart ensures each new track resets the timer.
  - id: auto_hide_track_info
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return id(is_ui_hidden);'
          then:
            - script.execute: toggle_ui
      - if:
          condition:
            lambda: 'return id(track_info_duration).state > 0;'
          then:
            - delay: !lambda 'return (uint32_t)(id(track_info_duration).state * 1000);'
            - if:
                condition:
                  lambda: 'return !id(is_ui_hidden);'
                then:
                  - script.execute: toggle_ui

text_sensor:
  - platform: homeassistant
    entity_id: ${media_player}
    id: media_title_sensor
    attribute: media_title
    on_value:
      # #region agent log
      - lambda: 'ESP_LOGI("dbg", "H6 TITLE_UPDATE: [%s] first=%d sntp=%d ts=%d pos=%.1f", x.c_str(), id(title_received_once) ? 0 : 1, id(sntp_time).now().is_valid() ? 1 : 0, id(last_position_timestamp), id(last_media_position));'
      # #endregion
      # Auto-show track info overlay (and start auto-hide timer)
      - script.execute: auto_hide_track_info
      # Track changed (skip/next) — dim stale artwork while new art loads.
      - lvgl.widget.update:
          id: album_art_background_widget
          opa: 40%
      - lvgl.widget.hide: artwork_error_label
      - lvgl.label.update:
          id: media_title_label
          text: !lambda 'return x.empty() ? std::string("—") : x;'
      # On first title push after boot (reconnect sync), skip position reset
      # so we don't wipe the real position received from media_position_sensor.
      # On real track changes (subsequent pushes), reset to 0 for instant feedback.
      - if:
          condition:
            lambda: 'return id(title_received_once);'
          then:
            - lambda: |-
                id(last_media_position) = 0.0f;
                id(ha_position_epoch) = 0;
                auto t = id(sntp_time).now();
                if (t.is_valid()) {
                  id(last_position_timestamp) = t.timestamp;
                }
            - lvgl.label.update:
                id: media_time_label
                text: "0:00 / -0:00"
            - lvgl.bar.update:
                id: media_progress_bar
                value: 0
          else:
            - lambda: 'id(title_received_once) = true;'

  - platform: homeassistant
    entity_id: ${media_player}
    id: media_artist_sensor
    attribute: media_artist
    on_value:
      - lvgl.label.update:
          id: media_artist_label
          text: !lambda 'return x.empty() ? std::string("—") : x;'

  - platform: homeassistant
    entity_id: ${media_player}
    id: media_entity_picture_sensor
    attribute: entity_picture
    on_value:
      - if:
          condition:
            lambda: 'return !x.empty();'
          then:
            # New artwork URL — dim stale artwork while new art loads.
            - lvgl.widget.update:
                id: album_art_background_widget
                opa: 40%
            - lvgl.widget.hide: artwork_error_label
            - online_image.set_url:
                id: album_art_background
                url: !lambda |-
                  std::string path = x;
                  while (!path.empty() && (path.back() == '\n' || path.back() == '\r' || path.back() == ' ')) path.pop_back();
                  return std::string("${home_assistant_url}") + path;
            # Album art appeared — if we're in TV mode, music is now playing.
            - if:
                condition:
                  lambda: 'return id(is_tv_mode);'
                then:
                  - script.execute: enter_music_mode

  - platform: homeassistant
    entity_id: ${media_player}
    id: media_player_state_sensor
    on_value:
      # #region agent log
      - lambda: 'ESP_LOGI("dbg", "H2 STATE_UPDATE: [%s] sntp=%d", x.c_str(), id(sntp_time).now().is_valid() ? 1 : 0);'
      # #endregion
      - if:
          condition:
            lambda: 'return x == "playing";'
          then:
            - script.stop: backlight_wake_timeout
            - lvgl.resume:
            - lvgl.widget.hide:
                id: media_play_icon
            - lvgl.widget.show:
                id: media_pause_icon
            - light.turn_on:
                id: backlight
                brightness: 100%
          else:
            - lvgl.widget.show:
                id: media_play_icon
            - lvgl.widget.hide:
                id: media_pause_icon
            - script.execute: backlight_wake_timeout

  - platform: homeassistant
    entity_id: ${media_player}
    id: media_source_sensor
    attribute: source
    on_value:
      - if:
          condition:
            lambda: 'return x == "TV";'
          then:
            - script.execute: enter_tv_mode
          else:
            - script.execute: enter_music_mode

  # HA reports media_position as of media_position_updated_at (often seconds stale).
  # Parse the UTC timestamp so the interval timer can compensate for staleness.
  - platform: homeassistant
    entity_id: ${media_player}
    id: media_position_updated_at_sensor
    attribute: media_position_updated_at
    on_value:
      - lambda: |-
          // #region agent log
          ESP_LOGI("dbg", "H7 POS_UPDATED_AT: raw=[%s]", x.c_str());
          // #endregion
          // Parse ISO 8601 UTC datetime to UNIX epoch
          int yr, mo, dy, hr, mn, sc;
          if (sscanf(x.c_str(), "%d-%d-%dT%d:%d:%d", &yr, &mo, &dy, &hr, &mn, &sc) != 6 &&
              sscanf(x.c_str(), "%d-%d-%d %d:%d:%d", &yr, &mo, &dy, &hr, &mn, &sc) != 6) {
            ESP_LOGW("dbg", "H7 POS_UPDATED_AT: parse failed");
            return;
          }
          // Convert UTC date to days since epoch, then to seconds
          int y = yr, m = mo;
          if (m <= 2) { y--; m += 12; }
          long days = 365L*y + y/4 - y/100 + y/400 + (153*(m-3)+2)/5 + dy - 719469;
          int epoch = (int)(days * 86400L + hr * 3600 + mn * 60 + sc);
          id(ha_position_epoch) = epoch;
          // #region agent log
          ESP_LOGI("dbg", "H7 POS_UPDATED_AT: epoch=%d sntp_now=%d delta=%d",
            epoch,
            id(sntp_time).now().is_valid() ? (int)id(sntp_time).now().timestamp : 0,
            id(sntp_time).now().is_valid() ? (int)(id(sntp_time).now().timestamp - epoch) : -1);
          // #endregion
          // If media_position was already received, correct its timestamp now
          if (id(media_position_sensor).has_state()) {
            id(last_position_timestamp) = epoch;
          }

sensor:
  - platform: homeassistant
    entity_id: ${media_player}
    id: media_duration_sensor
    attribute: media_duration
    on_value:
      # #region agent log
      - lambda: 'ESP_LOGI("dbg", "H4 DUR_UPDATE: dur=%.1f", x);'
      # #endregion
      - lvgl.label.update:
          id: media_time_label
          text: !lambda |-
            int d = (int)x; if (d < 0) d = 0;
            float pos = id(last_media_position);
            int e = (int)pos; if (e < 0) e = 0;
            int rem = d - e; if (rem < 0) rem = 0;
            char buf[24];
            snprintf(buf, sizeof(buf), "%d:%02d / -%d:%02d", e / 60, e % 60, rem / 60, rem % 60);
            return std::string(buf);

  - platform: homeassistant
    entity_id: ${media_player}
    id: media_position_sensor
    attribute: media_position
    on_value:
      - lambda: |-
          // #region agent log
          ESP_LOGI("dbg", "H3 POS_UPDATE: x=%.1f sntp=%d ts_before=%d ha_epoch=%d",
            x, id(sntp_time).now().is_valid() ? 1 : 0, id(last_position_timestamp), id(ha_position_epoch));
          // #endregion
          id(last_media_position) = x;
          // Prefer HA's own timestamp (compensates for stale position data,
          // especially important on reboot when the position could be many
          // seconds old). Fall back to SNTP time for fresh updates.
          if (id(ha_position_epoch) != 0) {
            id(last_position_timestamp) = id(ha_position_epoch);
          } else {
            auto t = id(sntp_time).now();
            if (t.is_valid()) id(last_position_timestamp) = t.timestamp;
          }
          // #region agent log
          ESP_LOGI("dbg", "H3 POS_UPDATE_AFTER: ts_after=%d pos=%.1f", id(last_position_timestamp), id(last_media_position));
          // #endregion
      - lvgl.label.update:
          id: media_time_label
          text: !lambda |-
            int e = (int)x; if (e < 0) e = 0;
            float dur = id(media_duration_sensor).has_state() ? id(media_duration_sensor).state : 0.0f;
            int d = (int)dur; if (d < 0) d = 0;
            int rem = d - e; if (rem < 0) rem = 0;
            char buf[24];
            snprintf(buf, sizeof(buf), "%d:%02d / -%d:%02d", e / 60, e % 60, rem / 60, rem % 60);
            return std::string(buf);
      - lvgl.bar.update:
          id: media_progress_bar
          value: !lambda |-
            float pos = x;
            float dur = id(media_duration_sensor).state;
            if (dur > 0) {
              return (int)((pos / dur) * 100.0f);
            }
            return 0;

  # Volume level: syncs the settings panel arc + label with HA
  - platform: homeassistant
    entity_id: ${media_player}
    id: media_volume_sensor
    attribute: volume_level
    on_value:
      - lvgl.arc.update:
          id: volume_arc
          value: !lambda 'return (int)(x * 100.0f);'
      - lvgl.label.update:
          id: volume_pct_label
          text: !lambda |-
            char buf[8];
            snprintf(buf, sizeof(buf), "%d%%", (int)(x * 100.0f));
            return std::string(buf);


# -----------------------------------------------------------------------------
# USER-CONFIGURABLE SETTINGS (exposed to Home Assistant)
# -----------------------------------------------------------------------------
# How long track info (title, artist, time, play/pause) stays visible after
# a track change before auto-hiding. Set to 0 to keep info always visible.
# -----------------------------------------------------------------------------
number:
  - platform: template
    name: "Track Info Duration"
    id: track_info_duration
    min_value: 0
    max_value: 60
    step: 1
    initial_value: 0
    optimistic: true
    restore_value: true
    unit_of_measurement: "s"
    icon: "mdi:timer-outline"
    entity_category: config
    mode: box
